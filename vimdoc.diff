diff --git a/runtime/doc/builtin.txt b/runtime/doc/builtin.txt
index f6a791d9f..e99a81302 100644
--- a/runtime/doc/builtin.txt
+++ b/runtime/doc/builtin.txt
@@ -5581,7 +5581,7 @@ matchfuzzy({list}, {str} [, {dict}])			*matchfuzzy()*
 
 		If {list} is a list of dictionaries, then the optional {dict}
 		argument supports the following additional items:
-		    key		key of the item which is fuzzy matched against
+		    key		Key of the item which is fuzzy matched against
 				{str}. The value of this item should be a
 				string.
 		    text_cb	|Funcref| that will be called for every item
@@ -5589,6 +5589,8 @@ matchfuzzy({list}, {str} [, {dict}])			*matchfuzzy()*
 				This should accept a dictionary item as the
 				argument and return the text for that item to
 				use for fuzzy matching.
+		    limit	Maximum number of matches in {list} to be
+				returned.  Zero means no limit.
 
 		{str} is treated as a literal string and regular expression
 		matching is NOT supported.  The maximum supported {str} length
@@ -5601,6 +5603,9 @@ matchfuzzy({list}, {str} [, {dict}])			*matchfuzzy()*
 		empty list is returned. If length of {str} is greater than
 		256, then returns an empty list.
 
+		When {limit} is given, matchfuzzy() will find up to this
+		number of matches in {list} and return them in sorted order.
+
 		Refer to |fuzzy-matching| for more information about fuzzy
 		matching strings.
 
diff --git a/runtime/doc/channel.txt b/runtime/doc/channel.txt
index 01756f145..ae9043050 100644
--- a/runtime/doc/channel.txt
+++ b/runtime/doc/channel.txt
@@ -25,6 +25,7 @@ The Netbeans interface also uses a channel. |netbeans|
 12. Job options				|job-options|
 13. Controlling a job			|job-control|
 14. Using a prompt buffer		|prompt-buffer|
+15. Language Server Protocol		|language-server-protocol|
 
 {only when compiled with the |+channel| feature for channel stuff}
 	You can check this with: `has('channel')`
@@ -424,6 +425,7 @@ To send a message, without expecting a response: >
 The process can send back a response, the channel handler will be called with
 it.
 
+						*channel-onetime-callback*
 To send a message and letting the response handled by a specific function,
 asynchronously: >
     call ch_sendraw(channel, {string}, {'callback': 'MyHandler'})
@@ -528,7 +530,8 @@ ch_evalexpr({handle}, {expr} [, {options}])			*ch_evalexpr()*
 
 		ch_evalexpr() waits for a response and returns the decoded
 		expression.  When there is an error or timeout it returns an
-		empty string.
+		empty |String| or, when using the "lsp" channel mode, returns an
+		empty |Dict|.
 
 		Note that while waiting for the response, Vim handles other
 		messages.  You need to make sure this doesn't cause trouble.
@@ -696,6 +699,16 @@ ch_sendexpr({handle}, {expr} [, {options}])			*ch_sendexpr()*
 		{handle} can be a Channel or a Job that has a Channel.
 		When using the "lsp" channel mode, {expr} must be a |Dict|.
 
+		If the channel mode is "lsp", then returns a Dict. Otherwise
+		returns an empty String.  If the "callback" item is present in
+		{options}, then the returned Dict contains the ID of the
+		request message.  The ID can be used to send a cancellation
+		request to the LSP server (if needed).  Returns an empty Dict
+		on error.
+
+		If a response message is not expected for {expr}, then don't
+		specify the "callback" item in {options}.
+
 		Can also be used as a |method|: >
 			GetChannel()->ch_sendexpr(expr)
 
@@ -1383,7 +1396,7 @@ The same in |Vim9| script: >
 	startinsert
 
 ==============================================================================
-14. Language Server Protocol			*language-server-protocol*
+15. Language Server Protocol			*language-server-protocol*
 
 The language server protocol specification is available at:
 
@@ -1394,11 +1407,19 @@ payload encoded in JSON-RPC format.  This is described in:
 
     https://www.jsonrpc.org/specification
 
-For messages received on a channel with mode set to "lsp", Vim will process
-the HTTP header and decode the payload into a Vim |Dict| type and call the
-channel callback or the specified callback function.  When sending messages on
-a channel using |ch_evalexpr()| or |ch_sendexpr()|, Vim will add the HTTP
-header and encode the Vim expression into JSON-RPC.
+To encode and send a LSP request/notification message in a Vim |Dict| into a
+LSP JSON-RPC message and to receive and decode a LSP JSON-RPC
+response/notification message into a Vim |Dict|, connect to the LSP server
+with the |channel-mode| set to "lsp".
+
+For messages received on a channel with |channel-mode| set to "lsp", Vim will
+process the HTTP header and decode the JSON-RPC payload into a Vim |Dict| type
+and call the |channel-callback| function or the specified
+|channel-onetime-callback| function.  When sending messages on a channel using
+the |ch_evalexpr()| or |ch_sendexpr()| functions, Vim will add the HTTP header
+and encode the Vim expression into JSON.  Refer to |json_encode()| and
+|json_decode()| for more information about how Vim encodes and decodes the
+builtin types into JSON.
 
 To open a channel using the 'lsp' mode, set the 'mode' item in the |ch_open()|
 {options} argument to 'lsp'.  Example: >
@@ -1408,37 +1429,73 @@ To open a channel using the 'lsp' mode, set the 'mode' item in the |ch_open()|
 To open a channel using the 'lsp' mode with a job, set the 'in_mode' and
 'out_mode' items in the |job_start()| {options} argument to 'lsp'. Example: >
 
-    let job = job_start(...., #{in_mode: 'lsp', out_mode: 'lsp'})
-
-To synchronously send a JSON-RPC request to the server, use the |ch_evalexpr()|
-function. This function will return the response from the server. You can use
+    let cmd = ['clangd', '--background-index', '--clang-tidy']
+    let opts = {}
+    let opts.in_mode = 'lsp'
+    let opts.out_mode = 'lsp'
+    let opts.out_cb = function('LspOutCallback')
+    let opts.err_cb = function('LspErrCallback')
+    let opts.exit_cb = function('LspExitCallback')
+    let job = job_start(cmd, opts)
+
+To synchronously send a JSON-RPC request to the server, use the
+|ch_evalexpr()| function. This function will wait and return the decoded
+response message from the server. You can use either the |channel-timeout| or
 the 'timeout' field in the {options} argument to control the response wait
-time. Example: >
+time.  If the request times out, then an empty |Dict| is returned.  Example: >
 
     let req = {}
     let req.method = 'textDocument/definition'
     let req.params = {}
     let req.params.textDocument = #{uri: 'a.c'}
     let req.params.position = #{line: 10, character: 3}
-    let resp = ch_evalexpr(ch, req, #{timeout: 100})
+    let defs = ch_evalexpr(ch, req, #{timeout: 100})
+    if defs->empty()
+        ... <handle failure>
+    endif
 
 Note that in the request message the 'id' field should not be specified. If it
 is specified, then Vim will overwrite the value with an internally generated
 identifier.  Vim currently supports only a number type for the 'id' field.
+The callback function will be invoked for both a successful and a failed RPC
+request.
 
 To send a JSON-RPC request to the server and asynchronously process the
-response, use the |ch_sendexpr()| function and supply a callback function.
-Example: >
+response, use the |ch_sendexpr()| function and supply a callback function.  If
+the "id" field is present in the request message, then Vim will overwrite it
+with an internally generated number.  This function returns a Dict with the
+identifier used for the message.  This can be used to send cancellation
+request to the LSP server (if needed).  Example: >
 
     let req = {}
     let req.method = 'textDocument/hover'
+    let req.id = 200
     let req.params = {}
     let req.params.textDocument = #{uri: 'a.c'}
     let req.params.position = #{line: 10, character: 3}
-    let resp = ch_sendexpr(ch, req, #{callback: 'MyFn'})
+    let resp = ch_sendexpr(ch, req, #{callback: 'HoverFunc'})
+
+To cancel an outstanding asynchronous LSP request sent to the server using the
+|ch_sendexpr()| function, send a cancelation message to the server using the
+|ch_sendexpr()| function with the ID returned by the |ch_sendexpr()| function
+for the request.  Example: >
+
+    " send a completion request
+    let req = {}
+    let req.method = 'textDocument/completion'
+    let req.params = {}
+    let req.params.textDocument = #{uri: 'a.c'}
+    let req.params.position = #{line: 10, character: 3}
+    let reqstatus = ch_sendexpr(ch, req, #{callback: 'LspComplete'})
+    " send a cancellation notification
+    let notif = {}
+    let notif.method = '$/cancelRequest'
+    let notif.id = reqstatus.id
+    call ch_sendexpr(ch, notif)
 
 To send a JSON-RPC notification message to the server, use the |ch_sendexpr()|
-function. Example: >
+function. As the server will not send a response message to the notification,
+don't specify the "callback" item.  Example: >
 
     call ch_sendexpr(ch, #{method: 'initialized'})
 
@@ -1454,4 +1511,68 @@ from the server request message. Example: >
 The JSON-RPC notification messages from the server are delivered through the
 |channel-callback| function.
 
+Depending on the use case, you can use the ch_evalexpr(), ch_sendexpr() and
+ch_sendraw() functions on the same channel.
+
+A LSP request message has the following format (expressed as a Vim Dict).  The
+"params" field is optional: >
+
+    {
+	"jsonrpc": "2.0",
+	"id": <number>,
+	"method": <string>,
+	"params": <list|dict>
+    }
+
+A LSP reponse message has the following format (expressed as a Vim Dict).  The
+"result" and "error" fields are optional: >
+
+    {
+	"jsonrpc": "2.0",
+	"id": <number>,
+	"result": <vim type>
+	"error": <dict>
+    }
+
+A LSP notification message has the following format (expressed as a Vim Dict).
+The "params" field is optional: >
+
+    {
+	"jsonrpc": "2.0",
+	"method": <string>,
+	"params": <list|dict>
+    }
+
+Depending on the use case, you can use the ch_evalexpr(), ch_sendexpr() and
+ch_sendraw() functions on the same channel.
+
+A LSP request message has the following format (expressed as a Vim Dict).  The
+"params" field is optional: >
+
+    {
+	"jsonrpc": "2.0",
+	"id": <number>,
+	"method": <string>,
+	"params": <list|dict>
+    }
+
+A LSP reponse message has the following format (expressed as a Vim Dict).  The
+"result" and "error" fields are optional: >
+
+    {
+	"jsonrpc": "2.0",
+	"id": <number>,
+	"result": <vim type>
+	"error": <dict>
+    }
+
+A LSP notification message has the following format (expressed as a Vim Dict).
+The "params" field is optional: >
+
+    {
+	"jsonrpc": "2.0",
+	"method": <string>,
+	"params": <list|dict>
+    }
+
  vim:tw=78:ts=8:noet:ft=help:norl:
