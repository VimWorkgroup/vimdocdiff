diff --git a/runtime/doc/builtin.txt b/runtime/doc/builtin.txt
index 74e024d97..8a92ff6ec 100644
--- a/runtime/doc/builtin.txt
+++ b/runtime/doc/builtin.txt
@@ -6830,55 +6830,55 @@ printf({fmt}, {expr1} ...)				*printf()*
 			echo printf("%1$*2$.*3$f", 1.4142135, 6, 2)
 <			  1.41
 
-							*E1400*
+							*E1500*
 		You cannot mix positional and non-positional arguments: >
 			echo printf("%s%1$s", "One", "Two")
-<			E1400: Cannot mix positional and non-positional
+<			E1500: Cannot mix positional and non-positional
 			arguments: %s%1$s
 
-							*E1401*
+							*E1501*
 		You cannot skip a positional argument in a format string: >
 			echo printf("%3$s%1$s", "One", "Two", "Three")
-<			E1401: format argument 2 unused in $-style
+<			E1501: format argument 2 unused in $-style
 			format: %3$s%1$s
 
-							*E1402*
+							*E1502*
 		You can re-use a [field-width] (or [precision]) argument: >
 			echo printf("%1$d at width %2$d is: %01$*2$d", 1, 2)
 <			1 at width 2 is: 01
 
 		However, you can't use it as a different type: >
 			echo printf("%1$d at width %2$ld is: %01$*2$d", 1, 2)
-<			E1402: Positional argument 2 used as field
+<			E1502: Positional argument 2 used as field
 			width reused as different type: long int/int
 
-							*E1403*
+							*E1503*
 		When a positional argument is used, but not the correct number
 		or arguments is given, an error is raised: >
 			echo printf("%1$d at width %2$d is: %01$*2$.*3$d", 1, 2)
-<			E1403: Positional argument 3 out of bounds:
+<			E1503: Positional argument 3 out of bounds:
 			%1$d at width %2$d is: %01$*2$.*3$d
 
 		Only the first error is reported: >
 			echo printf("%01$*2$.*3$d %4$d", 1, 2)
-<			E1403: Positional argument 3 out of bounds:
+<			E1503: Positional argument 3 out of bounds:
 			%01$*2$.*3$d %4$d
 
-							*E1404*
+							*E1504*
 		A positional argument can be used more than once: >
 			echo printf("%1$s %2$s %1$s", "One", "Two")
 <			One Two One
 
 		However, you can't use a different type the second time: >
 			echo printf("%1$s %2$s %1$d", "One", "Two")
-<			E1404: Positional argument 1 type used
+<			E1504: Positional argument 1 type used
 			inconsistently: int/string
 
-							*E1405*
+							*E1505*
 		Various other errors that lead to a format string being
 		wrongly formatted lead to: >
 			echo printf("%1$d at width %2$d is: %01$*2$.3$d", 1, 2)
-<			E1405: Invalid format specifier:
+<			E1505: Invalid format specifier:
 			%1$d at width %2$d is: %01$*2$.3$d
 
 prompt_getprompt({buf})					*prompt_getprompt()*
diff --git a/runtime/doc/vim9class.txt b/runtime/doc/vim9class.txt
index b230cb800..6b51e86b6 100644
--- a/runtime/doc/vim9class.txt
+++ b/runtime/doc/vim9class.txt
@@ -150,7 +150,7 @@ If you try to set an object variable that doesn't exist you get an error: >
 A object variable cannot be accessed using the class name.
 
 Private variables ~
-							*E1332* *E1333*
+					*private-variable* *E1332* *E1333*
 On the other hand, if you do not want the object variables to be read directly,
 you can make them private.  This is done by prefixing an underscore to the
 name: >
@@ -182,7 +182,7 @@ number to the total number of lines: >
 	enddef
 <
 Private methods ~
-							*E1366*
+						*private-method* *E1366*
 If you want object methods to be accessible only from other methods of the
 same class and not used from outside the class, then you can make them
 private.  This is done by prefixing the method name with an underscore: >
@@ -203,7 +203,7 @@ the above class): >
     a._Foo()
 <
 Simplifying the new() method ~
-
+						*new()* *constructor*
 Many constructors take values for the object variables.  Thus you very often
 see this pattern: >
 
@@ -216,7 +216,8 @@ see this pattern: >
 	      this.col = col
 	   enddef
 	 endclass
-
+<
+							*E1390*
 Not only is this text you need to write, it also has the type of each
 variables twice.  Since this is so common a shorter way to write new() is
 provided: >
@@ -257,10 +258,15 @@ If the class extends a parent class, the same thing happens.  In the second
 step the object variables of the parent class are initialized first.  There is
 no need to call "super()" or "new()" on the parent.
 
-						*E1365*
+							*E1365*
 When defining the new() method the return type should not be specified.  It
 always returns an object of the class.
 
+							*E1386*
+When invoking an object method, the method name should be preceded by the
+object variable name.  A object method cannot be invoked using the class
+name.
+
 ==============================================================================
 
 3.  Class Variables and Methods			*Vim9-class-member*
@@ -281,7 +287,7 @@ prefix in the class where they are defined: >
 Since the name is used as-is, shadowing the name by a method argument name
 or local variable name is not allowed.
 
-							*E1374* *E1375*
+					    *E1374* *E1375* *E1384* *E1385*
 To access a class member outside of the class where it is defined, the class
 name prefix must be used.  A class member cannot be accessed using an object.
 
@@ -650,7 +656,7 @@ even when the variable name is invalid. *E1360* *E1362* *E1363*
 
 
 Default constructor ~
-
+							*default-constructor*
 In case you define a class without a new() method, one will be automatically
 defined.  This default constructor will have arguments for all the object
 variables, in the order they were specified.  Thus if your class looks like: >
